Colt Steele's Udemy Course: JavaScript Algorithms and Data Structures Masterclass

BIG O NOTATION

What's the idea here?
    - Imagine we have multiple implementations (ways to do) of the same function
    - How can we determine which one is the "best"?

Who cares?
    - It's important to have a precise vocabulary to talk about how our code performs
    - Useful for discussing trade-offs between different approaches
    - When your code slows down or crashes, identifying parts of the code that are inefficient can help us find pain points in our applications
    - It comes up in interviews!

What does "best" or "better" mean? It's referring to which implementation/method to solve the problem is:
    - faster
    - less memory-intensive

To test performance why not use timers? there's a problem with this
    - different machines will record different times
    - the same machine will record different times
    - for fast algorithms, speed measurements may not be precise enough?

If not time, then what?
    - rather than counting seconds, which are so variable... let's count the number of simple operations the computer has to perform!

Counting operations is hard!
    - depending on what we count, the number of operations can be as low as 2n or as high as 5n + 2. but regardless of the exact number, the number of operations grows roughly proportionally with n

Introducing...Big O
    - Big O Notation is a way to formalize fuzzy counting
    - It allows us to talk formally about how the runtime of an algorithm grows as the inputs grow
    - We won't care about the details, only the trends

Big O Definition
    - We say that an algorithm is big O of f of n - O(f(n)) - if the number of simple operations the computer has to do is eventually less than a constant times f of n - f(n) - as n increases
        -f(n) could be linear where (f(n) = n) meaning as n (input) grows run time is increasing just as much
        - f(n) could be quadratic where (f(n) = n²) meaning as n (input) grows runtime is increasing to the square of n
        - f(n) could be constant where (f(n) = 1) meaning as n (input) grows it doesn't really have an affect on runtime
        - f(n) could be something entirely different! 

REMEMBER: big O notation is just a generalized way for talking about how efficient an algorithm is as n (an input) grows, how does that affect change or reflect in runtime? All we care about is the general trend. Not counting out each of the operations going on.

Simplifying Big O Expressions
    - when determining the time complexity of an algorithm, there are some helpful rules of thumb for big O expressions.
        - constants don't matter.
        if a function were to have O(2n) you could simplify that to O(n). likewise, if a function had a O(500) you could simplify that to O(1) its how we say something is constant. if a function had a 0(13n²) you could simplify to O(n²)

Big O Shorthands
    - analyzing complexity with big O can get complicated
    there are several rules that can help
    - these rules don't ALWAYS work, but they are a helpful starting point
        1. Arithmetic operations are constant. so if we're adding something or subtracting or dividing and so on thats going to be constant runtime.
        2. Variable assignment is constant x equaling any number is about the same amount of runtime
        3. Accessing elements in an array (by index) or (by key) is constant
        4. In a loop, the complexity is the length of the loop times the complexity of whatever happens inside of the loop

Space Complexity
    - So far, we've been focusing on time complexity: how can we analyze the runtime of an algorithm as the size of the inputs increases?
    - But we can also use big O notation to analyze SPACE COMPLEXITY, how much additional memory do we need to allocate in order to run the code in our algorithm?

What about the inputs?
    - Sometimes you'll hear the term auxiliary space complexity to refer to space required by the algorithm, not including space taken up by inputs.
    - Unless otherwise noted, when we talk about space complexity, technically we'll be talking about auxiliary space complexity.

Space Complexity in JS 
    - Rules of Thumb
        - most primitives (booleans, numbers, undefined, null) are constant space
        - strings require O(n) space (where n is the string length)
        - reference types are generally O(n), where n is the length (for arrays) or the number of keys (for objects)
